#pragma kernel GenerateKernel
#pragma kernel KernelTransform
#pragma kernel SourceTexture
#pragma kernel FftForward

Texture2D<float3> _Input;
RWTexture2D<float3> _Result;
RWTexture2D<float4> _FftResult;
SamplerState _LinearClampSampler;
float3 _Tint;
float2 _Scale, _Offset;
float _Intensity;
uint _Resolution;

const static uint SourceTextureSize = 1024;
const static float Pi = radians(180.0);

groupshared float2 groupSharedBuffer[SourceTextureSize];

[numthreads(8, 8, 1)]
void GenerateKernel(uint2 id : SV_DispatchThreadID)
{
	float2 uv = (id + 0.5) / _Resolution;
	uv = (2.0 * uv - 1.0) * _Scale * 0.5 + 0.5 + _Offset;
	float3 kernel = _Input.SampleLevel(_LinearClampSampler, uv, 0.0) * _Tint * _Intensity;
	_Result[id] = kernel;
}

[numthreads(8, 8, 1)]
void KernelTransform(uint2 id : SV_DispatchThreadID)
{
	_Result[id] = _Input[(id + (_Resolution >> 1)) % _Resolution];
}

[numthreads(8, 8, 1)]
void SourceTexture(uint2 id : SV_DispatchThreadID)
{
	float2 uv = (id + 0.5) / _Resolution;
	_Result[id] = _Input.SampleLevel(_LinearClampSampler, uv, 0.0);
}

uint ReversLowerNBits(uint bits, uint N)
{
	return reversebits(bits) >> (32 - N);
}

float2 ComplexMultiply(float2 A, float2 B)
{
	return float2(A.x * B.x - A.y * B.y, A.x * B.y + B.x * A.y);
}

float2 ComplexConjugate(float2 Z)
{
	return float2(Z.x, -Z.y);
}

float2 W_N_k(uint N, uint k)
{
	float theta = 2 * Pi * float(k) / float(N);
	return float2(cos(theta), -sin(theta));
}

float2 CooleyTukeyFFT(in float2 f_n, in uint index, in bool bIsForward)
{
	uint reverseIndex = ReversLowerNBits(index, log2(SourceTextureSize));
	GroupMemoryBarrierWithGroupSync();
	groupSharedBuffer[reverseIndex] = f_n;

	for (uint N = 2; N <= SourceTextureSize; N *= 2)
	{
		uint i = index % N;
		uint k = index % (N / 2);
		uint evenStartIndex = index - i;
		uint oddStartIndex = evenStartIndex + N / 2;
		
		GroupMemoryBarrierWithGroupSync();
		float2 F_even_k = groupSharedBuffer[evenStartIndex + k];
		float2 F_odd_k = groupSharedBuffer[oddStartIndex + k];

		float2 W = W_N_k(N, k);
		if (!bIsForward)
			W = ComplexConjugate(W);
		
		float2 F_k;
		if (i < N / 2)
			F_k = F_even_k + ComplexMultiply(W, F_odd_k);
		else
			F_k = F_even_k - ComplexMultiply(W, F_odd_k);
		
		GroupMemoryBarrierWithGroupSync();
		groupSharedBuffer[index] = F_k;
	}

	GroupMemoryBarrierWithGroupSync();
	float2 F_k = groupSharedBuffer[index];
	return F_k / float(sqrt(SourceTextureSize));
}

void TwoForOneFFTForward(in float2 z_n, in uint index, out float2 X_k, out float2 Y_k)
{
	CooleyTukeyFFT(z_n, index, true);
	float2 Z_k = groupSharedBuffer[index] / float(sqrt(SourceTextureSize));

	uint rollIndex = (SourceTextureSize - index) % SourceTextureSize;
	float2 Z_k_c = ComplexConjugate(groupSharedBuffer[rollIndex] / float(sqrt(SourceTextureSize)));

	X_k = (Z_k + Z_k_c) / 2;
	Y_k = ComplexMultiply(float2(0, -1), (Z_k - Z_k_c) / 2);
}


// TwoForOneFFTForwardHorizontal
[numthreads(1024, 1, 1)]
void FftForward(uint threadIndex : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	uint2 uv = uint2(threadIndex, groupIndex);
	float4 src = float4(_Input[uv], 0.0);
    
	float2 inputs[2] = { float2(src.x, src.y), float2(src.z, src.w) };
	float2 outputs[4] = { float2(0, 0), float2(0, 0), float2(0, 0), float2(0, 0) };

	for (uint channel = 0; channel < 2; channel++)
	{
		float2 z_n = inputs[channel];
		float2 X_k = float2(0, 0);
		float2 Y_k = float2(0, 0);
		TwoForOneFFTForward(z_n, threadIndex, X_k, Y_k);
        
		outputs[channel * 2 + 0] = X_k;
		outputs[channel * 2 + 1] = Y_k;
	}

	uint2 uvRG = uv;
	uint2 uvBA = uint2(uv.x + SourceTextureSize, uv.y);
	_FftResult[uvRG] = float4(outputs[0], outputs[1]);
	_FftResult[uvBA] = float4(outputs[2], outputs[3]);
}

