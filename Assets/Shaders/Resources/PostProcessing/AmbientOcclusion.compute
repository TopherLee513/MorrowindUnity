#pragma kernel CSMain

#include "../../Common.hlsl"

RWTexture2D<float4> Result;

[numthreads(8,8,1)]
void CSMain (uint2 id : SV_DispatchThreadID)
{



	float3 N = GBufferNormal(id);
	
	float viewspaceZ = LinearEyeDepth(_CameraDepth[id]);
	float3 cPosV = ComputeViewspacePosition(id + 0.5, viewspaceZ);
	float3 viewV = normalize(-cPosV);
	float3 V = ViewToWorldDir(viewV, true);
	
	float NdotV;
	N = GetViewReflectedNormal(N, V, NdotV);
	
	float3 normalV = WorldToViewDir(N, true);
	float2 noise = _BlueNoise2D[id % 128];

	float screenspaceRadius = min(_MaxScreenRadius, _Radius / viewspaceZ);
	float ratio = saturate(_MaxScreenRadius / (_Radius / viewspaceZ));
	
	float4 result = 0.0;
	for (float i = 0; i < _DirectionCount; i++)
	{
		float phi = Pi / _DirectionCount * (i + noise.x);
		float3 directionV = float3(cos(phi), sin(phi), 0.0);
		
		float3 orthoDirectionV = ProjectOnPlane(directionV, viewV);
		float3 axisV = normalize(cross(directionV, viewV));
		float3 projNormalV = ProjectOnPlane(normalV, axisV);
	
		float sgnN = sign(dot(orthoDirectionV, projNormalV));
		float cosN = saturate(dot(projNormalV, viewV) / length(projNormalV));
		float n = sgnN * FastACos(cosN);
		
		float2 h;
		
		[unroll]
		for (uint side = 0; side < 2; side++)
		{
			// Find the intersection with the next pixel, and use that as the starting point for the ray
			float2 direction = directionV.xy * (2.0 * side - 1.0);
			float2 cell = id;
			float2 tMin = (cell - (id + 0.5)) / direction;
			float2 tMax = (cell - (id + 0.5) + 1.0) / direction;
			float t = Max2(max(tMin, tMax));
			float2 start = (id + 0.5) + direction * t;
			float2 end = (id + 0.5) + direction * screenspaceRadius;
			float2 step = (end - start) / _SampleCount;
			
			float lowHorizonCos = cos(n + (2.0 * side - 1.0) * HalfPi);
			float cHorizonCos = lowHorizonCos;
			
			for (float j = 0.0; j < _SampleCount; j++)
			{
				uint2 position = uint2(start + (j + 0.5) * step);
				
				if (all(position == id))
					continue;
				
				float SZ = LinearEyeDepth(_Depth[position]);
				float3 sPosV = ComputeViewspacePosition(position + 0.5, SZ);
				float3 sHorizonV = normalize(sPosV - cPosV);

				// Falloff
				float start = _WorldRadius * 0.75 * ratio;
				float end = _WorldRadius * ratio;
				float weight = saturate((end - distance(sPosV, cPosV)) / (end - start));
				float sHorizonCos = lerp(lowHorizonCos, dot(sHorizonV, viewV), weight);
			
				if (sHorizonCos >= cHorizonCos)
				{
					// If weighted horizon is greater than the previous sample, it becomes the new horizon
					cHorizonCos = sHorizonCos;
				}
				else if (dot(sHorizonV, viewV) < cHorizonCos)
				{
					// Otherwise, reduce the max horizon to attenuate thin features, but only if the -non- weighted sample is also below the current sample
					// This prevents the falloff causing objects to be treated as thin when they would not be otherwise
					cHorizonCos = max(lowHorizonCos, cHorizonCos - _ThinOccluderCompensation);
				}
			}

			h[side] = n + clamp((2.0 * side - 1.0) * FastACos(cHorizonCos) - n, -HalfPi, HalfPi);
			result.w += length(projNormalV) * (cosN + 2.0 * h[side] * sin(n) - cos(2.0 * h[side] - n)) / 4.0;
		}
		
		// see "Algorithm 2 Extension that computes bent normals b."
		float t0 = (6 * sin(h[0] - n) - sin(3 * h[0] - n) + 6 * sin(h[1] - n) - sin(3 * h[1] - n) + 16 * sin(n) - 3 * (sin(h[0] + n) + sin(h[1] + n))) / 12;
		float t1 = (-cos(3 * h[0] - n) - cos(3 * h[1] - n) + 8 * cos(n) - 3 * (cos(h[0] + n) + cos(h[1] + n))) / 12;
	
		float3 bentNormalL = normalize(float3(directionV.x * t0, directionV.y * t0, -t1));
		result.xyz += mul(RotFromToMatrix(float3(0, 0, -1), viewV), bentNormalL) * length(projNormalV);
	}
	
	result /= _DirectionCount;
		
	result.xyz = ViewToWorldDir(result.xyz, false);
	_Result[id] = PackOutput(result);
}
